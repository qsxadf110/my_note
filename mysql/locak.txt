读写锁
	共享锁=>读锁，共享的，多个用户同时读取同一个资源，互不干扰
	排它锁=>写锁，排他的，胡阻塞其他的写锁和读锁，给定的时间里只能有一个客户读取同一数据
	注：写锁的优先级比读锁高

	表锁：开销最小，锁定整张表（删除、插入、更新）
	行级锁：在存储引擎层实现（innodb有使用）
	死锁：两个或多个事务在同一资源上相互占用，并请求锁定对方占用的资源

事务日志
	存储引擎在修改表的数据时，只要修改其内存拷贝，在把修改行为记录到持久在硬盘上的事务日志中。采用的是追加的方式，
	因此写操作是硬盘上一小块区域内的顺序I/O，也称为预写试日志

自动提交
	mysql 默认采用自动提交模式，如果不显示开启一个事务，每个查询都被当成一个事务执行提交操作
	查看自动提交是否开启
		$ show VARIABLES like 'AUTOCOMMIT';
	设置  1或ON表示开启，0或OFF表示关闭，对myisam或者内存表，不会有影响
		$ set AUTOCOMMIT = 1;

	如果在一个事务中，混合使用了事务型和非事务型的表，正常提交没有影响，但如果需要回滚，非事务型的表中的数据就无法撤销

存储引擎
	innodb 
		自动崩溃恢复，可以将表数据和索引存放在单独的文件中
		基于聚簇索引建立，对主键查询有很高的性能
		二级索引（非主键索引）中必须包含主键列，主键列很大的话，其他所有的索引都会很大
		自动增长列必须是索引，如果是组合索引，也必须是第一列
	myisam 
		崩溃后无法安全恢复
		会将表存储在两个文件中：数据文件和索引文件，分别以.MYD和.MYI为拓展名
		对整张表加锁，而不是针对行。读取加共享锁，写入加排它锁。在表有读取查询的同时，也可以往表中插入新的记录（成为并发插入）
		对于是blob和text等长字段，可以基于其前500个字符创建索引，也支持全文索引（也可以优先选择innodb加上sphinx）
		可以压缩表，但为只读，读取单行记录不用解压整张表
		如果所有的查询长期的处于locked状态，那就是表锁的原因
		只将数据写入到内存，等待操作系统定期将数据刷出到磁盘上
		自动增长列可以是组合索引的其他列，这样插入记录后，自动增长列是按照组合索引的前面几列进行排序后递增的
	memory
		表级锁
		支持hash索引
		适用于快速访问数据，并且这些数据不会修改，重启以后丢失也没关系